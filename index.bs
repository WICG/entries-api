<link rel="icon" href="folder-icon.png">
<pre class=metadata>
Title: File and Directory Entries API
Shortname: EntriesAPI
Abstract: This specification documents web browser support for file
    and directory upload by drag-and-drop operations. It introduces
    types representing directories with methods for asynchronous
    traversal, and extends {{HTMLInputElement}} and
    {{DataTransferItem}} [[!HTML]].
Status: ED
ED: https://wicg.github.io/entries-api/
Level: 1
Editor: Joshua Bell, jsbell@google.com
Group: wicg
</pre>
<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    urlPrefix: infrastructure.html
        type: dfn
            text: strictly splitting; url: #strictly-split-a-string
    urlPrefix: forms.html
        type: interface
            text: input; url: #the-input-element
            text: type; for: input; url: #attr-input-type
        type: dfn
            text: selected files; url: #concept-input-type-file-selected
            text: file upload; url: #file-upload-state-(type=file)
    urlPrefix: webappapis.html
        type: dfn
            text: queue a task
    urlPrefix: interaction.html
        type: dfn
            text: drag data store; url: #drag-data-store
            text: drag data store item list; url: #drag-data-store-item-list
            text: drag data item kind; url: #the-drag-data-item-kind
            text: read/write mode; url: #concept-dnd-rw
            text: read-only mode; url: #concept-dnd-ro
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: Promise; url: #sec-promise-objects
spec: webidl; urlPrefix: https://heycam.github.io/webidl/
    type: dfn
        text: invoke the callback; url: #es-invoking-callback-functions
</pre>


<!-- ============================================================ -->
<h2 id=goals>Goals</h2>
<!-- ============================================================ -->

This specification documents the types and operations made available
by web browsers to script when a hierarchy of files and directories
are dragged and dropped onto a page or selected using form elements,
or equivalent user actions.

This is heavily based upon earlier drafts of [[file-system-api]] which
defines similar types in the context of a sandboxed file system,
including operations for creating and modifying files and directories,
but which has not been broadly adopted by web browsers.

<div class=note>
  The APIs described by this document was initially implemented in
  Google Chrome. Other browsers (at this time: Microsoft Edge and
  Mozilla Firefox) are starting to support subsets of Chrome's APIs
  and behavior. The intent of this document is to specify the common
  subset to ensure that the implementations are interoperable.
</div>

<!-- ============================================================ -->
<h2 id=concepts>Concepts</h2>
<!-- ============================================================ -->

<!-- ============================================================ -->
<h3 id=names-paths>Names and Paths</h3>
<!-- ============================================================ -->

A <dfn>name</dfn> is a string which:

    * does not contain '/' (U+002F SOLIDUS)
    * does not contain NUL (U+0000)
    * is not '.' (U+002E FULL STOP)
    * is not '..' (U+002E FULL STOP, U+002E FULL STOP)

A <dfn>path segment</dfn> is a non-empty [=/name=], '.' (U+002E FULL
STOP) or '..' (U+002E FULL STOP, U+002E FULL STOP).

A <dfn>relative path</dfn> is a string consisting of one or more
[=path segments=] joined by '/' (U+002F SOLIDUS).

An <dfn>absolute path</dfn> is a string consisting of '/' (U+002F
SOLIDUS), optionally followed by a [=relative path=].

A <dfn>path</dfn> is either a [=relative path=] or an [=absolute
path=].

A <dfn>valid path</dfn> is a {{USVString}} which is a [=path=].

<!-- ============================================================ -->
<h3 id=files-dirs>Files and Directories</h3>
<!-- ============================================================ -->

A <dfn>file</dfn> consists of binary data and a <dfn
for=file>name</dfn> (a non-empty [=/name=]).

A <dfn>directory</dfn> consists of a <dfn for=directory>name</dfn> (a
[=/name=]) and an ordered list of members. Each member is either a
[=file=] or a [=directory=]. Each member of a [=directory=] must have
a distinct non-empty [=/name=].

A <dfn>root directory</dfn> is a [=directory=] that is not a member of
a [=directory=]. A [=root directory=]'s [=/name=] is empty.

The <dfn>parent</dfn> of a [=file=] or [=directory=] is the
[=directory=] it is a member of. A [=root directory=] has no
[=parent=].

<div class=issue>
  EDITORIAL:
  Should [=directory=] be defined as a special type of [=file=]
  so that minimal changes are necessary in [[HTML]]?
</div>

<div class=note>
  In most cases, the files and directories selected by the user will
  be presented by the API as if contained by a <em>virtual root</em>
  that does not exist as an entity in the actual file system backing
  the interaction with the API.
</div>

<!-- ============================================================ -->
<h3 id=entries>Entries</h3>
<!-- ============================================================ -->

An <dfn id=entry-concept>entry</dfn> is either a <dfn>file entry</dfn>
or a <dfn>directory entry</dfn>.

An [=entry=] has an <dfn for=entry>name</dfn> (a [=/name=]) and a
<dfn>full path</dfn> (an [=absolute path=]).

An [=entry=] also has a <dfn>root</dfn>, which is an associated [=root
directory=].

<div class=note>
  [=Entries=] are defined in terms of [=paths=] relative to a [=root
  directory=] to account for the fact that a file system backing the
  interaction with the API may be modified asynchronously during
  operations such as enumerating the contents of a directory.
  Operations exposed on [=entries=] may produce errors in such cases
  where the [=paths=] no longer reference the same entity.
</div>

<!-- ============================================================ -->
<h3 id=dir-reader>Directory Reader</h3>
<!-- ============================================================ -->

A <dfn>directory reader</dfn> consists of an associated [=directory
entry=], an associated [=directory=] (initially null), a <dfn>reading
flag</dfn> (initially unset), a <dfn>done flag</dfn> (initially
unset), and a <dfn>reader error</dfn> (initially null).


<!-- ============================================================ -->
<h2 id=algorithms>Algorithms</h2>
<!-- ============================================================ -->

To <dfn>resolve a relative path</dfn> with |abspath| (an [=absolute
path=]) and |relpath| (a [=relative path=]), run the following steps
which return an [=absolute path=]:

<div class=algorithm>

1. If |relpath| is an [=absolute path=], return |relpath|.

2. Let |abspath segments| be the result of [=strictly splitting=]
    |abspath| on '/' (U+002F SOLIDUS).

    <div class=note>The first string will be empty.</div>

3. Let |relpath segments| be the result of [=strictly splitting=]
    |relpath| on '/' (U+002F SOLIDUS).

4. For each |segment| in |relpath segments|, switch on |segment|:

    <dl class=switch>

      <dt>'.' (U+002E FULL STOP)
      <dd>Continue.

      <dt>'..' (U+002E FULL STOP, U+002E FULL STOP)
      <dd>Remove the last member of |abspath segments|
         unless it is the only member.

      <dt>Otherwise
      <dd>Append |segment| to |abspath segments|.

   </dl>

5. Return |abspath segments| joined by '/' (U+002F SOLIDUS).

</div>

To <dfn>evaluate a path</dfn> with |directory| (an [=root directory=])
and |path| (an [=absolute path=]), run the following steps which
return a [=file=], [=directory=], or <em>failure</em>.

<div class=algorithm>

1. Let |segments| be the result of [=strictly splitting=] |path| on
    '/' (U+002F SOLIDUS).

2. Remove the first entry from |segments|.

    <div class=note>Since |path| was an [=absolute path=],
      this first entry will always be empty.</div>

3. For each |segment| in |segments|, switch on |segment|:

    <dl class=switch>

      <dt>'.' (U+002E FULL STOP)
      <dd>Continue.

      <dt>'..' (U+002E FULL STOP, U+002E FULL STOP)
      <dd>Let |directory| be |directory|'s [=parent=],
          or |directory| if none.

      <dt>Otherwise
      <dd>
         Run these substeps:

         1. Let |item| be the member of |directory| with [=/name=]
            equal to |segment|, or return <em>failure</em> if none.

         2. If |segment| is the last item in |segments|, return
            |item|.

         3. If |item| is a [=file=], return <em>failure</em>.

         4. Let |directory| be |item|.
    </dl>

</div>

<!-- ============================================================ -->
<h2 id=html-forms>HTML Forms</h2>
<!-- ============================================================ -->

<div class=issue>
  EDITORIAL:
  This section should be merged into [[HTML]].
</div>

<pre class=idl>
partial interface HTMLInputElement {
    readonly attribute FrozenArray&lt;Entry&gt; webkitEntries;
};
</pre>

When an <{input}> element's <{input/type}> attribute is in the [=File
Upload=] state, the rules in this section apply.

The {{webkitEntries}} IDL attribute allows scripts to access the
element's selected entries. On getting, if the IDL attribute applies,
it must return an array of {{Entry}} objects that represent the
current [=selected files=] (including directories, if permitted). If
the IDL attribute does not apply, then it must instead return null.

<div class=issue>
  TODO:
  Define <code>webkitDirectory</code> and <code>webkitRelativePath</code>.
</div>


<!-- ============================================================ -->
<h2 id=api-data>Data Transfer</h2>
<!-- ============================================================ -->

<div class=issue>
EDITORIAL:
This section should be merged into [[HTML]].
</div>

During a <em>drag-and-drop operation</em>, [=file=] and
[=directory=] items are associated with [=entries=]. Each
[=entry=] is a member of a [=root directory=] unique to the
[=drag data store=].

Additionally, each [=directory=] item is represented in the [=drag
data store item list=] as a <i>File</i>. If it is accessed via
{{getAsFile()}} a zero-length {{File}} is returned.

<div class=note>
  A user agent may represent any hierarchical data as files and
  directories during a drag-and-drop operation. For example, audio
  data stored in a relational database with separate tables for albums
  metadata and blobs for tracks could be exposed to script as
  directories and files.
</div>

<pre class=idl>
partial interface DataTransferItem {
    Entry? webkitGetAsEntry();
};
</pre>

The {{webkitGetAsEntry()}} method must run the following steps when invoked:

<div class=algorithm>

1. If the {{DataTransferItem}} object is not in the <a>read/write
    mode</a> or the [=read-only mode=], return null and abort these
    steps.

2. If the [=drag data item kind=] is not <em>File</em>, then return
    null and abort these steps.

3. Return a new {{Entry}} object representing the [=entry=].

</div>

<div class=example>
Handling drag and drop of files and directories:
<pre class=lang-javascript>
elem.addEventListener('drop', e => {
  // Prevent navigation.
  e.preventDefault();

  // Process all of the items.
  for (let i = 0; i < e.dataTransfer.items.length; ++i) {
    let item = e.dataTransfer.items[i];

    // kind will be 'file' for file/directory entries.
    if (item.kind === 'file') {
      let entry = item.webkitGetAsEntry();
      handleEntry(entry);
    }
  }
});
</pre>
</div>


<!-- ============================================================ -->
<h2 id=api-files-directories>Files and Directories</h2>
<!-- ============================================================ -->

<h3 id=common-types>Common Types</h3>

<pre class=idl>
[Exposed=(Window,Worker)]
interface FileError : DOMError {
    const unsigned short NOT_FOUND_ERR = 1;
    const unsigned short SECURITY_ERR = 2;
    const unsigned short ABORT_ERR = 3;
    const unsigned short NOT_READABLE_ERR = 4;
    const unsigned short ENCODING_ERR = 5;
    const unsigned short NO_MODIFICATION_ALLOWED_ERR = 6;
    const unsigned short INVALID_STATE_ERR = 7;
    const unsigned short SYNTAX_ERR = 8;
    const unsigned short INVALID_MODIFICATION_ERR = 9;
    const unsigned short QUOTA_EXCEEDED_ERR = 10;
    const unsigned short TYPE_MISMATCH_ERR = 11;
    const unsigned short PATH_EXISTS_ERR = 12;

    readonly attribute unsigned short code;
};
</pre>

When a |name| <dfn>file error</dfn> is to be created, create
a new {{FileError}} object with the given |name|, with the
<em>code</em> from the table below and a <em>message</em> such as the
description from the table below.

<div class=note>
  User agents are encouraged to give more specific and meaningful
  error messages to allow developers to debug their code, while
  ensuring security and privacy is maintained.
</div>

<style>
table.deets { border-collapse: collapse; }
table.deets th { border-bottom: 2px solid silver; vertical-align: top; }
table.deets td { border-bottom: 1px solid silver; vertical-align: top; }
table.deets .used:after { color: #080; content: "\2713"; font-size: 200%; }
table.deets .unused:after { color: #800; content: "\2717"; font-size: 200%; }
</style>

<table class=deets>
  <tr>
    <th>Name</th>
    <th>Description</th>
    <th>Code and value</th>
    <th>Used?</th>
  </tr>
  <tr>
    <td>"<dfn exception><code>NotFoundError</code></dfn>"</td>
    <td class=long>
      A requested file or directory could not be found at the time an
      operation was processed.
    </td>
    <td>{{NOT_FOUND_ERR}} (1)</td>
    <td class=used></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>SecurityError</code></dfn>"</td>
    <td class=long>
      It was determined that certain files are unsafe for access
      within a Web application, or that too many calls are being made
      on file resources.
    </td>
    <td>{{SECURITY_ERR}} (2)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>AbortError</code></dfn>"</td>
    <td class=long>
      An ongoing operation was aborted, typically with a call to
      abort().
    </td>
    <td>{{ABORT_ERR}} (3)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>NotReadableError</code></dfn>"</td>
    <td class=long>
      The requested file could not be read, typically due to
      permission problems that have occurred after a reference to a
      file was acquired.
    </td>
    <td>{{NOT_READABLE_ERR}} (4)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>EncodingError</code></dfn>"</td>
    <td class=long>
      A URI supplied to the API was malformed, or the resulting Data
      URL has exceeded the URL length limitations for Data URLs.
    </td>
    <td>{{ENCODING_ERR}} (5)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>NoModificationAllowedError</code></dfn>"</td>
    <td class=long>
      An attempt was made to write to a file or directory which could
      not be modified due to the state of the underlying filesystem.
    </td>
    <td>{{NO_MODIFICATION_ALLOWED_ERR}} (6)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>InvalidStateError</code></dfn>"</td>
    <td class=long>
      An operation that depends on state cached in an interface object
      was made but the state had changed since it was read from disk.
    </td>
    <td>{{INVALID_STATE_ERR}} (7)</td>
    <td class=used></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>SyntaxError</code></dfn>"</td>
    <td class=long>
      An invalid or unsupported argument was given, like an invalid
      line ending specifier.
    </td>
    <td>{{SYNTAX_ERR}} (8)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>InvalidModificationError</code></dfn>"</td>
    <td class=long>
      An operation that depends on state cached in an interface object
      was made but the state had changed since it was read from disk.
    </td>
    <td>{{INVALID_MODIFICATION_ERR}} (9)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>QuotaExceededError</code></dfn>"</td>
    <td class=long>
      The operation failed because it would cause the application to
      exceed its storage quota.
    </td>
    <td>{{QUOTA_EXCEEDED_ERR}} (10)</td>
    <td class=unused></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>TypeMismatchError</code></dfn>"</td>
    <td class=long>
      The path supplied exists, but was not an entry of requested
      type.
    </td>
    <td>{{TYPE_MISMATCH_ERR}} (11)</td>
    <td class=used></td>
  </tr>
  <tr>
    <td>"<dfn exception><code>PathExistsError</code></dfn>"</td>
    <td class=long>
      An attempt was made to create a file or directory where an
      element already exists.
    </td>
    <td>{{PATH_EXISTS_ERR}} (12)</td>
    <td class=unused></td>
  </tr>
</table>

<div class=issue>
  WEB-COMPAT:
  We would like to eliminate {{DOMError}} from the platform in favor
  of {{DOMException}}. Is using {{FileError}} here necessary for
  web-compat?

  Note that the codes here differ from those in {{DOMException}}:
  {{NOT_FOUND_ERR}} = 1 vs. 8,
  {{SECURITY_ERR}} = 2 vs. 18,
  {{ABORT_ERR}} = 3 vs. 20,
  {{INVALID_STATE_ERR}} = 7 vs. 11,
  {{SYNTAX_ERR}} = 8 vs. 12,
  {{INVALID_MODIFICATION_ERR}} = 9 vs. 13,
  {{QUOTA_EXCEEDED_ERR}} = 10 vs. 22,
  {{TYPE_MISMATCH_ERR}} = 11 vs. [=simple exception=] <code>TypeError</code>.

  <a href="http://httparchive.org/">HTTP Archive</a> search for
  <code>FileError\.[A-Z_]+_ERR</code> shows only a small number of hits,
  all from either FileReader, use of Chrome's File System API, or
  PhoneGap/Cordova libraries.

  Chrome is planning to attempt the removal.
</div>

<pre class=idl>
callback interface ErrorCallback {
    void handleEvent(FileError err);
};
</pre>

An {{ErrorCallback}} function is used for operations that may return an
error asynchronously.



<!-- ============================================================ -->
<h3 id=api-entry>The {{Entry}} Interface</h3>
<!-- ============================================================ -->

<pre class=idl>
[NoInterfaceObject]
interface Entry {
    readonly attribute boolean isFile;
    readonly attribute boolean isDirectory;
    readonly attribute USVString name;
    readonly attribute USVString fullPath;

    void getParent(optional EntryCallback successCallback,
                   optional ErrorCallback errorCallback);
};
</pre>

<div class=issue>
  WEB-COMPAT: The <code>[NoInterfaceObject]</code> extended attribute
  is present on these in Chrome, hiding the types from the global
  namespace. Is it web-compatible to remove it, and simply expose
  these types in the global namespace as is done for most web APIs?
</div>

An {{Entry}} has an associated [=entry=].

The {{isFile}} attribute of the {{Entry}} interface must return true
if the [=entry=] is a [=file entry=] and false otherwise.

The {{isDirectory}} attribute of the {{Entry}} interface must return
true if the [=entry=] is a [=directory entry=] and false otherwise.

The {{name}} attribute of the {{Entry}} interface must return the
[=entry/name=] of the [=entry=].

The {{fullPath}} attribute of the {{Entry}} interface must return the
[=full path=] of the [=entry=].

The <dfn method for=Entry>getParent(|successCallback|,
|errorCallback|)</dfn> method, when invoked, must run the following
steps:

<div class=algorithm>

1. [=Queue a task=] to perform the following substeps:

    1. Let |path| be the result of running the steps to
        [=resolve a relative path=] with the [=entry=]'s
        [=full path=] and '..'.

    2. Let |item| be the result of running the steps to
        [=evaluate a path=] with the [=entry=]'s [=root=] and
        |path|.

    3. If |item| is <em>failure</em>, [=invoke the
        callback=] |errorCallback| (if given) with a
        "{{NotFoundError}}" [=file error=], and
        terminate these steps.

    4. Let |entry| be a new [=directory entry=] with
        |item|'s [=directory/name=] as [=entry/name=]
        and |path| as [=full path=].

    5. [=Invoke the callback=] |successCallback| with a
        new {{DirectoryEntry}} object associated with
        |entry|.

</div>

<div class=note>
  An error is possible if files have been modified on disk since the
  {{Entry}} was created.
</div>

<div class=example>
Handling an entry:
<pre class=lang-javascript>
function handleEntry(entry) {
  console.log('name: ' + entry.name);
  console.log('path: ' + entry.fullPath);
  if (entry.isFile) {
    console.log('... is a file');
  } else if (entry.isDirectory) {
    console.log('... is a directory');
  }
}
</pre>
</div>

<div class=example>
Helper function to adapt {{getParent()}} for use with [=Promises=]
[[ECMA-262]]:
<pre class=lang-javascript>
function getParentAsPromise(entry) {
  return new Promise((resolve, reject) => {
    entry.getParent(resolve, reject);
  });
}
</pre>
</div>

<!-- ============================================================ -->
<h3 id=api-directoryentry>The {{DirectoryEntry}} Interface</h3>
<!-- ============================================================ -->

<pre class=idl>
[NoInterfaceObject]
interface DirectoryEntry : Entry {
    DirectoryReader createReader();
    void getFile(USVString path,
                 optional Flags options,
                 optional EntryCallback successCallback,
                 optional ErrorCallback errorCallback);
    void getDirectory(USVString path,
                      optional Flags options,
                      optional EntryCallback successCallback,
                      optional ErrorCallback errorCallback);
};

dictionary Flags {};

callback interface EntryCallback {
    void handleEvent(Entry entry);
};
</pre>

A {{DirectoryEntry}}'s associated [=entry=] is a [=directory entry=].

The <dfn method for=DirectoryEntry>createReader()</dfn> method, when
invoked, must run the following steps:

<div class=algorithm>

1. Let |reader| be a new [=directory reader=] associated with the
    [=directory entry=]'s [=directory=].

2. Return a newly created {{DirectoryReader}} object associated with
    |reader|.

</div>


The <dfn method for=DirectoryEntry>getFile(|path|, |options|,
|successCallback|, |errorCallback|)</dfn> method, when invoked, must
run the following steps:

<div class=algorithm>

1. [=Queue a task=] to run the following substeps:

    1. If |path| is not a [=valid path=], [=invoke the callback=]
        |errorCallback| (if given) with a "{{TypeMismatchError}}"
        [=file error=], and terminate these steps.

    2. Let |path| be the result of running the steps to [=resolve a
        relative path=] with the [=directory entry=]'s [=full path=]
        and |path|.

    3. Let |item| be the result of running the steps to [=evaluate a
        path=] with the [=directory entry=]'s [=root=] and |path|.

    4. If |item| is <em>failure</em>, [=invoke the callback=]
        |errorCallback| (if given) with a "{{NotFoundError}}" [=file
        error=], and terminate these steps.

    5. If |item| is not a [=file=], [=invoke the callback=]
        |errorCallback| (if given) with a "{{TypeMismatchError}}" [=file
        error=], and terminate these steps.

    6. Let |entry| be a new [=file entry=] with |item|'s [=file/name=]
        as [=entry/name=] and |path| as [=full path=].

    7. [=Invoke the callback=] |successCallback| (if given) with a new
        {{FileEntry}} object associated with |entry|.

</div>

The <dfn method for=DirectoryEntry>getDirectory(|path|, |options|,
|successCallback|, |errorCallback|)</dfn> method, when invoked, must
run the following steps:

<div class=algorithm>

1. [=Queue a task=] to run the following substeps:

    1. If |path| is not a [=valid path=], [=invoke the callback=]
        |errorCallback| (if given) with a "{{TypeMismatchError}}"
        [=file error=], and terminate these steps.

    2. Let |path| be the result of running the steps to [=resolve a
        relative path=] with the [=directory entry=]'s [=full path=]
        and |path|.

    3. Let |item| be the result of running the steps to [=evaluate a
        path=] with the [=directory entry=]'s [=root=] and |path|.

    4. If |item| is <em>failure</em>, [=invoke the callback=]
        |errorCallback| (if given) with a "{{NotFoundError}}" [=file
        error=], and terminate these steps.

    5. If |item| is not a [=directory=], [=invoke the callback=]
        |errorCallback| (if given) with a "{{TypeMismatchError}}"
        [=file error=], and terminate these steps.

    6. Let |entry| be a new [=directory entry=] with |item|'s
        [=directory/name=] as [=entry/name=] and |path| as [=full
        path=].

    7. [=Invoke the callback=] |successCallback| (if given) with a new
        {{DirectoryEntry}} associated with |entry|.

</div>

<div class=note>
  The {{Flags}} dictionary has no defined members and is present for
  compatibility with existing implementations.
</div>

<div class=issue>
  WEB-COMPAT:
  If the file is not present, Chrome gives "{{SecurityError}}" if
  <code>{create:true}</code> is passed as |options|, and
  "{{NotFoundError}}" otherwise. Is this necessary for web-compat?
</div>

<div class=example>
Helper functions to adapt {{getFile()}} and {{getDirectory()}} for use
with [=Promises=] [[ECMA-262]]:
<pre class=lang-javascript>
function getFileAsPromise(entry, path) {
  return new Promise((resolve, reject) => {
    entry.getFile(path, {}, resolve, reject);
  });
}
function getDirectoryAsPromise(entry, path) {
  return new Promise((resolve, reject) => {
    entry.getDirectory(path, {}, resolve, reject);
  });
}
</pre>
</div>


<!-- ============================================================ -->
<h3 id=api-directoryreader>The {{DirectoryReader}} Interface</h3>
<!-- ============================================================ -->

<pre class=idl>
[NoInterfaceObject]
interface DirectoryReader {
    void readEntries(EntriesCallback successCallback,
                     optional ErrorCallback errorCallback);
};
callback interface EntriesCallback {
    void handleEvent(sequence&lt;Entry&gt; entries);
};
</pre>

The <dfn method for="DirectoryEntry">readEntries(|successCallback|,
|errorCallback|)</dfn> method, when invoked, must run the following
steps:

<div class=algorithm>

1. If the [=directory reader=]'s [=reading flag=] is set, [=queue a
    task=] to [=invoke the callback=] |errorCallback| with an
    "{{InvalidStateError}}" [=file error=], and terminate these steps.

2. If the [=directory reader=]'s [=reader error=] is not null, [=queue
    a task=] to [=invoke the callback=] |errorCallback| (if given)
    with [=reader error=], and terminate these steps.

3. If the [=directory reader=]'s [=done flag=] is set, [=queue a
    task=] to [=invoke the callback=] |successCallback| with an empty
    sequence and terminate these steps.

4. Set the [=directory reader=]'s [=reading flag=].

5. [=Queue a task=] to perform the following substeps:

    1. Clear the [=directory reader=]'s [=reading flag=].

    2. Let |dir| be the [=directory reader=]'s [=directory=].

    3. If |dir| is null, run these substeps:

        1. Let |dir| be the result of running the steps to [=evaluate
            a path=] with the [=entry=]'s [=root=] and [=full path=].

        2. If |dir| is failure, set the [=directory reader=]'s
            [=reader error=] to a new "{{NotFoundError}}" [=file
            error=], [=invoke the callback=] |errorCallback| (if
            given) with [=reader error=], and terminate these steps.

        3. Set the [=directory reader=]'s [=directory=] to |dir|.

    4. Let |entries| be a non-zero number of entries from the
        |dir| that have not yet been produced by this
        [=directory reader=], if any.

    5. If the previous step failed (for example, the [=directory=] was
        deleted or permission is denied), then set the [=directory
        reader=]'s [=reader error=] to an appropriate [=file error=],
        [=invoke the callback=] |errorCallback| (if given) with
        [=reader error=], and terminate these steps.

    6. If |entries| is empty, set the [=directory reader=]'s [=done
        flag=].

    7. [=Invoke the callback=] |successCallback| with |entries|.

</div>


<div class=example>
Enumerating a directory:
<pre class=lang-javascript>
let reader = dirEntry.createReader();
let doBatch = function() {

    // Read a batch.
    reader.readEntries(entries => {

      // Complete?
      if (entries.length === 0) {
        return;
      }

      // Process the batch.
      entries.forEach(handleEntry);

      // Read the next batch.
      doBatch();

    }, error => console.warn(error));
  };

// Start reading
doBatch();
</pre>
</div>

<div class=example>
Helper function to adapt {{DirectoryReader}} for use with
[=Promises=] [[ECMA-262]]:
<pre class=lang-javascript>
function getEntriesAsPromise(entry) {
  return new Promise((resolve, reject) => {
    let result = [];
    let reader = dirEntry.createReader();
    let doBatch = () => {
      reader.readEntries(entries => {
        if (entries.length > 0) {
          entries.forEach(e => result.push(e));
          doBatch();
        } else {
          resolve(result);
        }
      }, reject);
    };
    doBatch();
  });
}
</pre>
</div>

<div class=example>
Helper function to adapt {{DirectoryReader}} for use with
<a href="https://github.com/zenparsing/es-observable">Observables</a>:
<pre class=lang-javascript>
function getEntriesAsObservable(entry) {
  return new Observable(observer => {
    let reader = dirEntry.createReader();
    let doBatch = () => {
      reader.readEntries(entries => {
        if (entries.length > 0) {
          entries.forEach(e => observer.next(e));
          doBatch();
        } else {
          observer.complete();
        }
      }, reject);
    };
    doBatch();
  });
}
</pre>
</div>

<!-- ============================================================ -->
<h3 id=api-fileentry>The {{FileEntry}} Interface</h3>
<!-- ============================================================ -->

<pre class=idl>
[NoInterfaceObject]
interface FileEntry : Entry {
    void file(FileCallback successCallback,
              optional ErrorCallback errorCallback);
};
callback interface FileCallback {
    void handleEvent(File file);
};
</pre>

A {{FileEntry}}'s associated [=entry=]
is a [=file entry=].

The <dfn method for="FileEntry">file(|successCallback|,
|errorCallback|)</dfn> method, when invoked, must run the following
steps:

<div class=algorithm>

1. [=Queue a task=] to perform the following substeps:

    1. Let |item| be the result of running the steps to [=evaluate a
        path=] with the [=file entry=]'s [=root=] and [=full path=].

    2. If |item| is <em>failure</em>, [=invoke the callback=]
        |errorCallback| (if given) with a "{{NotFoundError}}" [=file
        error=], and terminate these steps.

    3. If |item| is a [=directory=], [=invoke the callback=]
        |errorCallback| (if given) with a "{{TypeMismatchError}}"
        [=file error=], and terminate these steps.

    4. [=Invoke the callback=] |successCallback| with a new {{File}}
        object representing |item|.

</div>

<div class=example>
Read the contents of a dropped file using {{FileReader}}:
<pre class=lang-javascript>
function readFileEntry(entry) {
  entry.file(file => {
    let reader = new FileReader();
    reader.readAsText(file);
    reader.onerror = error => console.warn(error);
    reader.onload = () => {
      console.log(reader.result);
    };
  }, error => console.warn(error));
}
</pre>
</div>

<div class=example>
Helper function to adapt {{file()}} for use with [=Promises=]
[[ECMA-262]]:
<pre class=lang-javascript>
function fileAsPromise(entry) {
  return new Promise((resolve, reject) => {
    entry.file(resolve, reject);
  });
}
</pre>
</div>


<h2 id=acknowledgements>Acknowledgements</h2>

This specification is based heavily on the work of Eric Uhrhane in
[[file-system-api]], which introduced the {{Entry}} types.

Thanks to Tab Atkins, Jr. for creating and maintaining <a
href="https://github.com/tabatkins/bikeshed">Bikeshed</a>, the
specification authoring tool used to create this document.

And thanks to
Ali Alabbas,
Marijn Kruisselbrink,
and
smaug----
for suggestions, reviews, and other feedback.
