<!DOCTYPE html>
<meta charset=utf-8>
<title>Entries API: DirectoryEntry manual test</title>
<link rel=help href="https://wicg.github.io/entries-api">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/idlharness.js"></script>

<h1>Entries API: FileEntry manual test</h1>

<div id=drop>
  Drop the <b>upload</b> directory here.
</div>

<style>
#drop { height: 50px; border: 1px dotted red; }
</style>


<script>
setup({explicit_timeout: true});

const tests = [];
const elem = document.getElementById('drop');
elem.addEventListener('dragover', e => {
  e.preventDefault();
});
elem.addEventListener('drop', e => {
  e.preventDefault();
  const entry = e.dataTransfer.items[0].webkitGetAsEntry();
  window.entry = entry;
  elem.parentElement.removeChild(elem);

  tests.forEach(f => f(entry));
});


// Registers a test to be run when an entry is dropped. Calls |func|
// with (test, entry); |func| and must call `test.done()` when complete.
function entry_test(func, description) {
  const test = async_test(description);
  tests.push(test.step_func(arg => func(test, arg)));
}
function run_tests(arg) {
}

// Registers a test to be run when an entry is dropped. Digs the named
// |file| out of the dropped entry and calls |func| with
// (test, file_entry); |func| must call `test.done()` when complete.
function file_entry_test(name, func, description) {
  return entry_test((t, entry) => {
    entry.getFile(
      name, {},
      t.step_func(entry => func(t, entry)),
      t.unreached_func('getFile should not fail'));
  }, description);
}


// ----------------------------------------
// Paths
// ----------------------------------------

const INVALID_PATHS = [
  '\x00', 'a-\x00-b',
  '\x0B', 'a-\x0B-b',
];
const EMPTY_PATHS = ['', null, undefined];
const NOT_FOUND_PATHS = ['nope', '/upload/nope', './nope', 'subdir/../nope'];

const DIR_PATHS = [
  'subdir',
  '/upload/subdir',
  './subdir',
  'subdir/.',
  'subdir/../subdir',
  'subdir/./../subdir',
  'subdir/../subdir/.',
  '//upload/subdir',
  '/upload//subdir',
  './/subdir',
  'subdir//.',
];
const FILE_PATHS = [
  'file.txt',
  '/upload/file.txt',
  'subdir/../file.txt',
  '//upload/file.txt',
  '/upload//file.txt',
  'subdir/./../file.txt',
];

// ----------------------------------------
// Entry
// TODO: Move to separate file
// ----------------------------------------

entry_test((t, entry) => {
  assert_false('Entry' in self, 'Entry has [NoInterfaceObject]');

  assert_idl_attribute(entry, 'isFile', 'Entry has isFile attribute');
  assert_equals(typeof entry.isFile, 'boolean', 'isFile is boolean');

  assert_idl_attribute(entry, 'isDirectory', 'Entry has isDirectory attribute');
  assert_equals(typeof entry.isDirectory, 'boolean', 'isFile is boolean');

  assert_idl_attribute(entry, 'name', 'Entry has name attribute');
  assert_equals(typeof entry.name, 'string', 'name is a string');

  assert_idl_attribute(entry, 'fullPath', 'Entry has fullPath attribute');
  assert_equals(typeof entry.fullPath, 'string', 'fullPath is a string');

  assert_idl_attribute(entry, 'filesystem', 'Entry has filesystem attribute');
  assert_class_string(entry.filesystem, 'DOMFileSystem', 'filesystem is a DOMFileSystem');

  assert_idl_attribute(entry, 'getParent', 'Entry has filesystem attribute');
  assert_equals(typeof entry.getParent, 'function', 'Entry has a getParent() method');

  t.done();
}, 'Entry - IDL');

entry_test((t, entry) => {
  assert_equals(entry.getParent(), void 0, 'getParent() arguments are optional');

  entry.getParent(t.step_func(parent => {
    assert_class_string(parent, 'DirectoryEntry', 'parent should be a directory');

    assert_equals(parent.fullPath, '/', 'parent should be root');
    assert_equals(parent.name, '', 'root name is empty string');

    t.done();
  }), t.unreached_func('getParent() should not fail'));
}, 'Entry - getParent()');

// TODO: Manual test for getParent() where containing directory is removed before getParent() is called.


// ----------------------------------------
// DirectoryEntry
// ----------------------------------------

entry_test((t, entry) => {
  // Entry ----------

  assert_idl_attribute(entry, 'isFile', 'DirectoryEntry has isFile attribute');
  assert_equals(typeof entry.isFile, 'boolean', 'isFile is boolean');

  assert_idl_attribute(entry, 'isDirectory', 'DirectoryEntry has isDirectory attribute');
  assert_equals(typeof entry.isDirectory, 'boolean', 'isDirectory is boolean');

  assert_idl_attribute(entry, 'name', 'DirectoryEntry has name attribute');
  assert_equals(typeof entry.name, 'string', 'name is a string');

  assert_idl_attribute(entry, 'fullPath', 'DirectoryEntry has fullPath attribute');
  assert_equals(typeof entry.fullPath, 'string', 'fullPath is a string');

  assert_idl_attribute(entry, 'filesystem', 'DirectoryEntry has filesystem attribute');
  assert_class_string(entry.filesystem, 'DOMFileSystem', 'filesystem is a DOMFileSystem');

  assert_idl_attribute(entry, 'getParent', 'DirectoryEntry has getParent');
  assert_equals(typeof entry.getParent, 'function', 'getParent() is a method');

  // DirectoryEntry  ----------

  assert_false('DirectoryEntry' in self, 'Entry has [NoInterfaceObject]');
  assert_class_string(entry, 'DirectoryEntry', 'interface name is DirectoryEntry');

  assert_idl_attribute(entry, 'getFile', 'DirectoryEntry has getFile');
  assert_equals(typeof entry.getFile, 'function',
                'getFile() is a method');

  assert_idl_attribute(entry, 'getDirectory', 'DirectoryEntry has getDirectory');
  assert_equals(typeof entry.getDirectory, 'function',
                'getDirectory() is a method');

  assert_idl_attribute(entry, 'createReader', 'DirectoryEntry has createReader');
  assert_equals(typeof entry.createReader, 'function',
                'createReader() is a method');

  t.done();
}, 'DirectoryEntry - IDL');

entry_test((t, entry) => {
  assert_false(entry.isFile, 'isFile is false');
  assert_true(entry.isDirectory, 'isDirectory is true');
  assert_equals(entry.name, 'upload', 'expected directory was uploaded');
  assert_equals(entry.fullPath, '/upload', 'directory is child of root directory');
  t.done();
}, 'DirectoryEntry - attributes');

// ----------------------------------------
// DirectoryEntry - getFile()
// ----------------------------------------

INVALID_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getFile() should fail if given invalid path');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - invalid path: ' + JSON.stringify(path));
});

EMPTY_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getFile() on empty path should fail because the ' +
                      'path resolves to the directory itself');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - empty path: ' + JSON.stringify(path) || 'undefined');
});

FILE_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {create: true},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'SecurityError',
                      'getFile() should fail with security error if ' +
                      'create option is set');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - {create:true}: ' + path);
});

NOT_FOUND_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'NotFoundError',
                      'getFile() should fail with not found');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - not found: ' + path);
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getFile() should fail if type is directory');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - directory: ' + path);
});

FILE_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.step_func(e => {
        assert_class_string(e, 'FileEntry', 'path should match');
        assert_true(e.isFile);
        assert_false(e.isDirectory);
        assert_equals(e.name, 'file.txt');
        t.done();
      }),
      t.unreached_func('getFile should not fail')
    );
  }, 'DirectoryEntry.getFile() - file: ' + path);
});

entry_test((t, entry) => {
  entry.getFile(FILE_PATHS[0], {}, t.step_func(e1 => {
    entry.getFile(FILE_PATHS[0], {}, t.step_func(e2 => {
      assert_equals(e1.name, e2.name, 'names should match');
      assert_equals(e1.fullPath, e2.fullPath, 'names should match');
      assert_not_equals(e1, e2, 'objects should be distinct');
      t.done();
    }), t.unreached_func('getFile should not fail'));
  }), t.unreached_func('getFile should not fail'));
}, 'DirectoryEntry.getFile() - object identity');


// ----------------------------------------
// DirectoryEntry - getDirectory()
// ----------------------------------------

INVALID_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getDirectory() should fail if given invalid path');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - invalid path: ' + JSON.stringify(path));
});

EMPTY_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.step_func(dir => {
        assert_class_string(dir, 'DirectoryEntry',
                          'empty path should yield DirectoryEntry');
        assert_equals(dir.name, entry.name,
                          'empty path should yield same directory');
        assert_equals(dir.fullPath, entry.fullPath,
                          'empty path should yield same directory');
        t.done();
      },
      t.unreached_func('getDirectory should not fail')
      ));
  }, 'DirectoryEntry.getDirectory() - empty path: '
   + JSON.stringify(path) || 'undefined');
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {create: true},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'SecurityError',
                      'getDirectory() should fail with security error if ' +
                      'create option is set');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - {create:true}: ' + path);
});

NOT_FOUND_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'NotFoundError',
                      'getDirectory() should fail with not found');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - not found: ' + path);
});

FILE_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getDirectory() should fail if type is file');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - directory: ' + path);
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.step_func(e => {
        assert_class_string(e, 'DirectoryEntry', 'path should match');
        assert_false(e.isFile);
        assert_true(e.isDirectory);
        assert_equals(e.name, 'subdir');
        t.done();
      }),
      t.unreached_func('getDirectory should not fail')
    );
  }, 'DirectoryEntry.getDirectory() - directory: ' + path);
});


// ----------------------------------------
// DirectoryReader
// TODO: Move to separate file
// ----------------------------------------

entry_test((t, entry) => {
  const reader = entry.createReader();

  assert_false('DirectoryReader' in self, 'DirectoryReader has [NoInterfaceObject]');
  assert_class_string(reader, 'DirectoryReader', 'interface name is DirectoryReader');

  assert_idl_attribute(reader, 'readEntries', 'DirectoryReader has readEntries');
  assert_equals(typeof reader.readEntries, 'function', 'readEntries() is a method');

  t.done();
}, 'DirectoryReader - IDL');


entry_test((t, entry) => {
  entry.getDirectory('subdir', {}, t.step_func(dir => {
    const reader = dir.createReader();
    assert_class_string(reader, 'DirectoryReader');
    assert_equals(typeof reader.readEntries, 'function');

    const found_names = [];
    const do_chunk = t.step_func(() =>
      reader.readEntries(t.step_func(entries => {

        if (entries.length > 0) {
          entries.forEach(t.step_func(entry => found_names.push(entry.name)));
          do_chunk();
          return;
        }

        found_names.sort();
        assert_array_equals(found_names, ['1.txt', '2.txt', '3.txt'],
                            'directory contents should match');
        t.done();
      })));

    do_chunk();
  }), t.unreached_func('getDirectory should not fail'));
}, 'DirectoryReader - basic enumeration');

entry_test((t, entry) => {
  const reader = entry.createReader();
  reader.readEntries(() => {}, t.unreached_func('readEntries should succeed'));
  reader.readEntries(
    t.unreached_func('readEntries() should fail if already reading'),
    t.step_func(error => {
      assert_equals(error.name, 'InvalidStateError', 'invalid state if already reading');
      t.done();
    }));
}, 'DirectoryReader - reading flag');

entry_test((t, entry) => {
  const reader = entry.createReader();

  const do_chunk = t.step_func(() =>
    reader.readEntries(t.step_func(entries => {
      if (entries.length > 0) {
        do_chunk();
        return;
      }
      reader.readEntries(t.step_func(entries => {
        assert_equals(
          entries.length, 0,
          'calling readEntries() when done should yield and empty sequence');
        t.done();
      }));
    })));

  do_chunk();
}, 'DirectoryReader - done flag');

// TODO: Manual tests where directory contents are changed during the test.


// ----------------------------------------
// FileEntry
// TODO: Move to separate file
// ----------------------------------------

file_entry_test('file.txt', (t, entry) => {
  // Entry ----------

  assert_idl_attribute(entry, 'isFile', 'Entry has isFile attribute');
  assert_equals(typeof entry.isFile, 'boolean', 'isFile is boolean');

  assert_idl_attribute(entry, 'isDirectory', 'Entry has isDirectory attribute');
  assert_equals(typeof entry.isDirectory, 'boolean', 'isFile is boolean');

  assert_idl_attribute(entry, 'name', 'Entry has name attribute');
  assert_equals(typeof entry.name, 'string', 'name is a string');

  assert_idl_attribute(entry, 'fullPath', 'Entry has fullPath attribute');
  assert_equals(typeof entry.fullPath, 'string', 'fullPath is a string');

  assert_idl_attribute(entry, 'filesystem', 'Entry has filesystem attribute');
  assert_class_string(entry.filesystem, 'DOMFileSystem', 'filesystem is a DOMFileSystem');

  assert_idl_attribute(entry, 'getParent', 'Entry has filesystem attribute');
  assert_equals(typeof entry.getParent, 'function', 'Entry has a getParent() method');

  // FileEntry ----------

  assert_false('FileEntry' in self, 'FileEntry has [NoInterfaceObject]');
  assert_class_string(entry, 'FileEntry', 'interface name is FileEntry');

  assert_equals(typeof entry.file, 'function', 'FileEntry has a file() method');
  t.done();
}, 'FileEntry - IDL');

file_entry_test('file.txt', (t, entry) => {
  assert_true(entry.isFile);
  assert_false(entry.isDirectory);
  assert_equals(entry.name, 'file.txt');
  assert_equals(entry.fullPath, '/upload/file.txt');
  t.done();
}, 'FileEntry - attributes');

file_entry_test('file.txt', (t, entry) => {
  assert_throws(TypeError(), () => entry.file(), 'file() has a required argument');
  entry.file(t.step_func(file => {

    assert_class_string(file, 'File', 'file() should yield a File');
    assert_equals(entry.name, file.name, 'entry and file names should match');
    t.done();

  }), t.unreached_func('file() should not fail'));
}, 'FileEntry - file()');

// TODO: Manual test where file is replaced with directory before file() called

// ----------------------------------------
// DOMFileSystem
// TODO: Move to separate file
// ----------------------------------------

entry_test((t, entry) => {
  const fs = entry.filesystem;

  assert_false('DOMFileSystem' in self, 'DOMFileSystem has [NoInterfaceObject]');
  assert_class_string(fs, 'DOMFileSystem', 'interface name is DOMFileSystem');

  assert_idl_attribute(fs, 'name', 'has name attribute');
  assert_equals(typeof fs.name, 'string', 'name is a string');

  assert_idl_attribute(fs, 'root', 'has root attribute');
  assert_class_string(fs.root, 'DirectoryEntry', 'DOMFileSystem root is a DirectoryEntry');

  assert_equals(fs.root.name, '', 'root name is empty string');

  assert_equals(fs.root.fullPath, '/', 'root path is /');

  t.done();

}, 'DOMFileSystem - API');

entry_test((t, entry) => {
  const fs = entry.filesystem;

  entry.getParent(t.step_func(parent => {
    const pfs = parent.filesystem;
    assert_not_equals(fs, pfs.filesystem, 'DOMFileSystem objects do not have object identity');
    assert_equals(fs.name, pfs.name, 'DOMFileSystem names match');

    t.done();
  }), t.unreached_func('getParent() should not fail'));

}, 'DOMFileSystem - name consistency and object identity');


// ----------------------------------------
// Errors
// TODO: Move to separate file
// ----------------------------------------

entry_test((t, entry) => {
  entry.getFile(
    NOT_FOUND_PATHS[0],
    {},
    t.unreached_func('getFile should fail'),
    t.step_func(error => {
      assert_equals(typeof error.name, 'string', 'Error has name property');
      assert_equals(typeof error.message, 'string', 'Error has message property');
      assert_equals(error.name, 'NotFoundError', 'error is NotFoundError');
      t.done();
    }));
}, 'Errors - NotFoundError');

entry_test((t, entry) => {
  entry.getFile(
    DIR_PATHS[0],
    {},
    t.unreached_func('getFile should fail'),
    t.step_func(error => {
      assert_equals(typeof error.name, 'string', 'Error has name property');
      assert_equals(typeof error.message, 'string', 'Error has message property');
      assert_equals(error.name, 'TypeMismatchError', 'error is TypeMismatchError');
      t.done();
    }));
}, 'Errors - TypeMismatchError');

entry_test((t, entry) => {
  entry.getFile(
    FILE_PATHS[0],
    {create: true},
    t.unreached_func('getFile should fail'),
    t.step_func(error => {
      assert_equals(typeof error.name, 'string', 'Error has name property');
      assert_equals(typeof error.message, 'string', 'Error has message property');
      assert_equals(error.name, 'SecurityError', 'error is SecurityError');
      t.done();
    }));
}, 'Errors - SecurityError');

entry_test((t, entry) => {
  const reader = entry.createReader();
  reader.readEntries(() => {}, t.unreached_func('readEntries should succeed'));
  reader.readEntries(
    t.unreached_func('readEntries() should fail if already reading'),
    t.step_func(error => {
      assert_equals(typeof error.name, 'string', 'Error has name property');
      assert_equals(typeof error.message, 'string', 'Error has message property');
      assert_equals(error.name, 'InvalidStateError', 'error is InvalidStateError');
      t.done();
    }));
}, 'Errors - InvalidStateError');

</script>
