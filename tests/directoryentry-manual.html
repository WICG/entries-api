<!DOCTYPE html>
<meta charset=utf-8>
<title>Entries API: DirectoryEntry manual test</title>
<link rel=help href="https://wicg.github.io/entries-api">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/idlharness.js"></script>

<h1>Entries API: FileEntry manual test</h1>

<div id=drop>
  Drop the <b>upload</b> directory here.
</div>

<style>
#drop { height: 50px; border: 1px dotted red; }
</style>


<script>
setup({explicit_timeout: true});

let elem = document.getElementById('drop');
elem.addEventListener('dragover', e => {
  e.preventDefault();
});
elem.addEventListener('drop', e => {
  e.preventDefault();
  run_tests(e.dataTransfer.items[0].webkitGetAsEntry());
  elem.parentElement.removeChild(elem);
});

let tests = [];
function entry_test(func, description) {
  let test = async_test(description);
  tests.push(test.step_func(arg => func(test, arg)));
}
function run_tests(arg) {
  tests.forEach(f => f(arg));
}

// ----------------------------------------
// DirectoryEntry
// ----------------------------------------

entry_test((t, entry) => {
  assert_class_string(entry, 'DirectoryEntry', 'interface name is DirectoryEntry');

  assert_idl_attribute(entry, 'isFile', 'has isFile attribute');
  assert_false(entry.isFile, 'isFile is false');

  assert_idl_attribute(entry, 'isDirectory', 'has isDirectory attribute');
  assert_true(entry.isDirectory, 'isDirectory is true');

  assert_idl_attribute(entry, 'name', 'has name attribute');
  assert_equals(entry.name, 'upload', 'expected directory was uploaded');

  assert_idl_attribute(entry, 'fullPath', 'has fullPath attribute');
  assert_equals(entry.fullPath, '/upload', 'directory is child of root directory');

  assert_idl_attribute(entry, 'filesystem', 'has filesystem attribute');
  assert_class_string(entry.filesystem, 'DOMFileSystem',
                      'filesystem returns a DOMFileSystem');

  assert_equals(typeof entry.createReader, 'function',
                'DirectoryEntry has a createReader() function');

  assert_equals(typeof entry.getParent, 'function',
                'DirectoryEntry has a getParent() function');

  assert_equals(typeof entry.getFile, 'function',
                'DirectoryEntry has a getFile() function');

  assert_equals(typeof entry.getDirectory, 'function',
                'DirectoryEntry has a getDirectory() function');

  let reader = entry.createReader();
  assert_class_string(reader, 'DirectoryReader',
                      'createReader() returns a DirectoryReader');

  t.done();
}, 'DirectoryEntry basic IDL');

// ----------------------------------------
// Paths
// ----------------------------------------

const INVALID_PATHS = ['\x00', 'a\x00b'];
const EMPTY_PATHS = ['', null, undefined];
const NOT_FOUND_PATHS = ['nope', '/upload/nope', './nope', 'subdir/../nope'];
const DIR_PATHS = [
  'subdir',
  '/upload/subdir',
  './subdir',
  'subdir/.',
  'subdir/../subdir',
  'subdir/./../subdir',
  'subdir/../subdir/.',
  '//upload/subdir',
  '/upload//subdir',
  './/subdir',
  'subdir//.',
];
const FILE_PATHS = [
  'file.txt',
  '/upload/file.txt',
  'subdir/../file.txt',
  '//upload/file.txt',
  '/upload//file.txt',
  'subdir/./../file.txt',
];

// ----------------------------------------
// getFile()
// ----------------------------------------

INVALID_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getFile() should fail if given invalid path');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - invalid path: ' + JSON.stringify(path));
});

EMPTY_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getFile() on empty path should fail because the ' +
                      'path resolves to the directory itself');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - empty path: ' + JSON.stringify(path) || 'undefined');
});

FILE_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {create: true},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'SecurityError',
                      'getFile() should fail with security error if ' +
                      'create option is set');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - {create:true}: ' + path);
});

NOT_FOUND_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'NotFoundError',
                      'getFile() should fail with not found');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - not found: ' + path);
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.unreached_func('getFile should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getFile() should fail if type is directory');
        t.done();
      }));
  }, 'DirectoryEntry.getFile() - directory: ' + path);
});

FILE_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getFile(
      path,
      {},
      t.step_func(e => {
        assert_class_string(e, 'FileEntry', 'path should match');
        assert_true(e.isFile);
        assert_false(e.isDirectory);
        assert_equals(e.name, 'file.txt');
        t.done();
      }),
      t.unreached_func('getFile should not fail')
    );
  }, 'DirectoryEntry.getFile() - file: ' + path);
});

entry_test((t, entry) => {
  entry.getFile(FILE_PATHS[0], {}, t.step_func(e1 => {
    entry.getFile(FILE_PATHS[0], {}, t.step_func(e2 => {
      assert_equals(e1.name, e2.name, 'names should match');
      assert_equals(e1.fullPath, e2.fullPath, 'names should match');
      assert_not_equals(e1, e2, 'objects should be distinct');
      t.done();
    }), t.unreached_func('getFile should not fail'));
  }), t.unreached_func('getFile should not fail'));
}, 'DirectoryEntry.getFile() - object identity');

// ----------------------------------------
// getDirectory()
// ----------------------------------------

INVALID_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getDirectory() should fail if given invalid path');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - invalid path: ' + JSON.stringify(path));
});

EMPTY_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.step_func(dir => {
        assert_class_string(dir, 'DirectoryEntry',
                          'empty path should yield DirectoryEntry');
        assert_equals(dir.name, entry.name,
                          'empty path should yield same directory');
        assert_equals(dir.fullPath, entry.fullPath,
                          'empty path should yield same directory');
        t.done();
      },
      t.unreached_func('getDirectory should not fail')
      ));
  }, 'DirectoryEntry.getDirectory() - empty path: '
   + JSON.stringify(path) || 'undefined');
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {create: true},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'SecurityError',
                      'getDirectory() should fail with security error if ' +
                      'create option is set');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - {create:true}: ' + path);
});

NOT_FOUND_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'NotFoundError',
                      'getDirectory() should fail with not found');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - not found: ' + path);
});

FILE_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getDirectory() should fail if type is file');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - directory: ' + path);
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.step_func(e => {
        assert_class_string(e, 'DirectoryEntry', 'path should match');
        assert_false(e.isFile);
        assert_true(e.isDirectory);
        assert_equals(e.name, 'subdir');
        t.done();
      }),
      t.unreached_func('getDirectory should not fail')
    );
  }, 'DirectoryEntry.getDirectory() - directory: ' + path);
});

// ----------------------------------------
// DirectoryReader
// TODO: Move to separate file
// ----------------------------------------

entry_test((t, entry) => {
  entry.getDirectory('subdir', {}, t.step_func(dir => {
    let reader = dir.createReader();
    assert_class_string(reader, 'DirectoryReader');
    assert_equals(typeof reader.readEntries, 'function');

    let found_names = [];
    let do_chunk = t.step_func(() =>
      reader.readEntries(t.step_func(entries => {

        if (entries.length > 0) {
          entries.forEach(t.step_func(entry => found_names.push(entry.name)));
          do_chunk();
          return;
        }

        found_names.sort();
        assert_array_equals(found_names, ['1.txt', '2.txt', '3.txt'],
                            'directory contents should match');
        t.done();
      })));

    do_chunk();
  }), t.unreached_func('getDirectory should not fail'));
}, 'DirectoryReader - basic enumeration');

entry_test((t, entry) => {
  let reader = entry.createReader();
  reader.readEntries(() => {}, t.unreached_func('readEntries should succeed'));
  reader.readEntries(
    t.unreached_func('readEntries() should fail if already reading'),
    t.step_func(error => {
      assert_equals(error.name, 'InvalidStateError', 'invalid state if already reading');
      t.done();
    }));
}, 'DirectoryReader - reading flag');

entry_test((t, entry) => {
  let reader = entry.createReader();

  let do_chunk = t.step_func(() =>
    reader.readEntries(t.step_func(entries => {
      if (entries.length > 0) {
        do_chunk();
        return;
      }

      reader.readEntries(t.step_func(entries => {
        assert_equals(
          entries.length, 0,
          'calling readEntries() when done should yield and empty sequence');
        t.done();
      }));
    })));

  do_chunk();

}, 'DirectoryReader - done flag');

// TODO: Manual tests where directory contents are changed during the test.

// ----------------------------------------
// Entry
// TODO: Move to separate file
// ----------------------------------------

entry_test((t, entry) => {
  assert_idl_attribute(entry, 'isFile', 'has isFile attribute');
  assert_equals(typeof entry.isFile, 'boolean', 'isFile is boolean');

  assert_idl_attribute(entry, 'isDirectory', 'has isDirectory attribute');
  assert_equals(typeof entry.isDirectory, 'boolean', 'isFile is boolean');

  assert_idl_attribute(entry, 'name', 'has name attribute');
  assert_equals(typeof entry.name, 'string', 'name is a string');

  assert_idl_attribute(entry, 'fullPath', 'has fullPath attribute');
  assert_equals(typeof entry.fullPath, 'string', 'fullPath is a string');

  assert_idl_attribute(entry, 'filesystem', 'has filesystem attribute');
  assert_class_string(entry.filesystem, 'DOMFileSystem',
                      'filesystem returns a DOMFileSystem');

  assert_equals(entry.getParent(), void 0, 'getParent() arguments are optional');
  entry.getParent(t.step_func(parent => {
    assert_class_string(parent, 'DirectoryEntry', 'parent should be a directory');

    assert_equals(parent.fullPath, '/', 'parent should be root');
    assert_equals(parent.name, '', 'root name is empty string');

    t.done();
  }), t.unreached_func('getParent() should not fail'));
});

// TODO: Manual test where file is replaced with directory before file() called

// ----------------------------------------
// FileEntry
// TODO: Move to separate file
// ----------------------------------------

entry_test((t, entry) => {
  entry.getFile('file.txt', {}, t.step_func(entry => {
    assert_class_string(entry, 'FileEntry', 'interface name is FileEntry');
    assert_true(entry.isFile);
    assert_false(entry.isDirectory);
    assert_equals(entry.name, 'file.txt');

    assert_equals(typeof entry.file, 'function', 'FileEntry has a file() method');
    assert_throws(TypeError(), () => entry.file(), 'file() has a required argument');
    entry.file(t.step_func(file => {

      assert_class_string(file, 'File', 'file() should yield a File');
      assert_equals(entry.name, file.name, 'entry and file names should match');
      t.done();

    }), t.unreached_func('file() should not fail'));

  }), t.unreached_func('getFile should not fail'));
});

// TODO: Manual test where file is replaced with directory before file() called

// ----------------------------------------
// DOMFileSystem
// TODO: implement
// TODO: Include tests that name is consistent
// ----------------------------------------


</script>
