<!DOCTYPE html>
<meta charset=utf-8>
<title>Entries API: DirectoryEntry.getDirectory() manual test</title>
<link rel=help href="https://wicg.github.io/entries-api/#dom-filesystemdirectoryentry-getdirectory">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/idlharness.js"></script>

<h1>Entries API: DirectoryEntry.getDirectory() manual test</h1>

<div id=drop style="height: 50px; border: 1px dotted red;">Drop the <b>support/upload</b> directory here.</div>
<script src="support.js"></script>

<script>
INVALID_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getDirectory() should fail if given invalid path');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - invalid path: ' + JSON.stringify(path));
});

EMPTY_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.step_func(dir => {
        assert_class_string(dir, 'DirectoryEntry',
                          'empty path should yield DirectoryEntry');
        assert_equals(dir.name, entry.name,
                          'empty path should yield same directory');
        assert_equals(dir.fullPath, entry.fullPath,
                          'empty path should yield same directory');
        t.done();
      },
      t.unreached_func('getDirectory should not fail')
      ));
  }, 'DirectoryEntry.getDirectory() - empty path: '
   + JSON.stringify(path) || 'undefined');
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {create: true},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'SecurityError',
                      'getDirectory() should fail with security error if ' +
                      'create option is set');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - {create:true}: ' + path);
});

NOT_FOUND_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'NotFoundError',
                      'getDirectory() should fail with not found');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - not found: ' + path);
});

FILE_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.unreached_func('getDirectory should fail'),
      t.step_func(error => {
        assert_equals(error.name, 'TypeMismatchError',
                      'getDirectory() should fail if type is file');
        t.done();
      }));
  }, 'DirectoryEntry.getDirectory() - directory: ' + path);
});

DIR_PATHS.forEach(path => {
  entry_test((t, entry) => {
    entry.getDirectory(
      path,
      {},
      t.step_func(e => {
        assert_class_string(e, 'DirectoryEntry', 'path should match');
        assert_false(e.isFile);
        assert_true(e.isDirectory);
        assert_equals(e.name, 'subdir');
        t.done();
      }),
      t.unreached_func('getDirectory should not fail')
    );
  }, 'DirectoryEntry.getDirectory() - directory: ' + path);
});
</script>
